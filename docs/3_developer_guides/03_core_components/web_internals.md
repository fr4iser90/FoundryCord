

## Guild Designer: Dashboard Builder & Preview

This section details the technical architecture for the interactive dashboard builder feature within the Guild Structure Designer.

### Overview

The goal is to allow users to visually construct dashboards using predefined components, configure them with variables, and see a live preview. These dashboards are stored as instances linked to specific channels in a Guild Template.

### Key Architectural Components

1.  **Backend - Component Definition API (`GET /api/v1/dashboards/components`):**
    *   **Purpose:** Provides the frontend (Toolbox, Editor) with the definitions of available building blocks.
    *   **Source:** Reads from the `dashboard_component_definitions` database table (seeded via Migration 009).
    *   **Response Structure (Conceptual):** Returns a list of component definitions. Each definition should include:
        *   `component_key`: Unique identifier (e.g., `common_text_block`).
        *   `dashboard_type`: The scope (e.g., `common`, `welcome`).
        *   `component_type`: Category (e.g., `layout`, `text`, `button`, `embed`).
        *   `metadata`: `{ displayName, description, icon, category }`.
        *   `config_schema`: An array describing configurable fields for the editor widget:
            *   `[{ key, label, fieldType, defaultValue?, options?, validation?, helpText?, supportsVariables? }]`.
        *   `preview_hints (Optional)`: Information for the preview widget.
    *   **Implementation:** Requires a new Controller, Service, and Repository specifically for reading and structuring these definitions. Pydantic schemas should be used for the response.
    *   **Filtering:** Should support filtering by `dashboard_type` and `component_type` via query parameters.

2.  **Backend - Variables API (`GET /api/v1/dashboards/variables` - Optional/Placeholder):**
    *   **Purpose:** Provides the Editor Widget with a list of available template variables.
    *   **Source:** Initially hardcoded, ideally later read from a dedicated database table (`dashboard_variables`).
    *   **Response Structure:** `[{ variable_key, description, example_value, scope? }]`.
    *   **Implementation:** New Controller/Service.

3.  **Backend - Instance Management API (Existing):**
    *   Endpoints `GET/POST /channels/.../dashboards` and `GET/PUT/DELETE /dashboards/{instance_id}` are used.
    *   Crucially, the `config` field within the request/response payloads for these endpoints now contains the complex JSON structure generated by the Editor Widget, representing the arranged and configured components.
  

4.  **Frontend - Toolbox (`panel/toolbox.js`):**
    *   Fetches component definitions from `GET /api/v1/dashboards/components`.
    *   Displays components, grouped by category/type, as draggable elements.
    *   Attaches component definition data (especially `component_key` and `definition`) to the draggable elements for use by the Editor Widget.

5.  **Frontend - Editor Widget (`widget/dashboardEditor.js`):**
    *   A GridStack widget, likely hidden by default.
    *   **Receives Components:** Implements drop handling for components dragged from the Toolbox.
    *   **Dynamic Form Generation:** Reads the `config_schema` from the dropped component's definition and dynamically renders the appropriate input fields (text, textarea, select, color picker, etc.) for configuration.
    *   **Variable Insertion:** Fetches variables from `GET /api/v1/dashboards/variables` and provides UI (e.g., a dropdown/button) to insert them into compatible fields.
    *   **State Management:** Maintains the internal structure of the dashboard being built (list of components, their order, their configured values).
    *   **Config Generation:** On save, serializes the internal structure into the complex `config` JSON format.
    *   **API Interaction:** Handles loading instance data (`GET`), saving updates (`PUT`), and creating new instances (`POST`) via the instance management API.
    *   **Activation:** Triggered via events from the Properties Panel (for 'New'/'Edit'). Hides itself after save/cancel.

6.  **Frontend - Preview Widget (`widget/dashboardPreview.js`):**
    *   A GridStack widget.
    *   **Data Loading:** Fetches the full instance data (including `config` JSON) for a selected instance (`GET /api/v1/dashboards/{instance_id}`).
    *   **Dynamic Rendering:** Parses the `config` JSON. For each component in the config, it fetches the corresponding component definition (potentially cached) from the `/dashboards/components` API (or uses data passed with the config).
    *   **Approximation:** Renders HTML elements attempting to visually mimic the Discord appearance based on the component type, configured properties, and `preview_hints`. Variables are replaced with placeholders.
    *   **Activation:** Triggered via events from the Properties Panel (when an instance is selected) or the Editor Widget (after save).

7.  **Frontend - Properties Panel (`properties.js`):**
    *   When a channel node is selected in the `structureTree`:
        *   Fetches the list of associated dashboard instances (`GET /channels/.../dashboards`).
        *   Displays the list (Name, Type).
        *   Adds a "New" button: Triggers the display/activation of the Editor Widget in 'create' mode (potentially requires a `dashboard_type` selection first).
        *   Adds "Edit" button per instance: Triggers the display/activation of the Editor Widget in 'edit' mode, passing the `instance_id`.
        *   Adds "Delete" button per instance: Triggers `DELETE /dashboards/{instance_id}`.
        *   Handles instance selection: Clicking an instance name triggers the Preview Widget to load and render the preview for that `instance_id`.

8.  **Event Handling (`designerEvents.js` / Widget Communication):**
    *   Crucial for coordinating actions between the Properties Panel, Editor Widget, and Preview Widget.
    *   Events needed for: triggering editor load/create, triggering preview load, signaling completion of save/delete to refresh lists/previews.

### Data Flow Example (Edit Instance)

1.  User selects Channel Node in `structureTree`.
2.  `properties.js` detects selection, calls `GET /api/v1/templates/channels/{channel_id}/dashboards`.
3.  `properties.js` displays the list of instances.
4.  User clicks "Edit" on instance `xyz`.
5.  `properties.js` dispatches `requestDashboardEdit` event with `instance_id: xyz`.
6.  `dashboardEditor.js` listens, receives event, calls `loadInstance('xyz')`.
7.  `loadInstance` calls `GET /api/v1/templates/dashboards/xyz`.
8.  Backend returns instance data (incl. `config` JSON).
9.  `dashboardEditor.js` parses `config`, fetches component definitions if needed (`GET /components`), dynamically renders editor UI, shows widget.
10. User edits, clicks "Save".
11. `dashboardEditor.js` generates new `config` JSON, calls `PUT /api/v1/templates/dashboards/xyz`.
12. Backend saves, returns success.
13. `dashboardEditor.js` hides widget, dispatches `dashboardInstanceUpdated` event with `instance_id: xyz`.
14. `properties.js` listens, refreshes its list.
15. `dashboardPreview.js` listens, calls `loadPreview('xyz')` to update the preview.
